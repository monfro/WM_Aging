function fb_copy_preprocess

global INFO;

fb_ifno_exp_BtH;        % get INFO structure
if isempty(whos('INFO')); error('Please provide INFO structure'); end   % check whether we have INFO structure

fb_copy_mridata;        % copy and order the MRI data files
initialise_SPM;         % initialize SPM and toolboxes
fb_ME_combine;          % combine multiecho data
fb_preprocess;          % do preprocessing of imaging data
fb_compsig;             % get compartments signals and combine them with realignment regressors

%nEchoes = 4;

% check for spaces (will cause batch to crash
if ~isempty(findstr(' ',target_dir))
    error('Please make sure the target path has no spaces in it');
end

% loop over subjects
for iSubj = 1:numel(INFO.subjects)
    % load file info that was save by fb_copy_mridata
    batch_info_savefolder = fullfile(INFO.dir.exp_root,INFO.subjects{iSubj},INFO.dir.info.batch);
    batch_info_savefile = fullfile(batch_info_savefolder,[mfilename,'.mat']);
    if ~exist(batch_info_savefile); error(['file ',batch_info_savefile,' does not exist. Run fb_copy_mridata first'); end
    subj_info           = load(batch_info_savefile);
    
    [u_dirs,o2,o3] = unique(subj_info.target_subdirs);
    u_types = subj_info.target_subdirs_type(o2);
    subdirs2exclude = [find(cellfun(@isempty,cellfun(@findstr,u_dirs,repmat({'excess'},size(u_dirs)),'UniformOutput',false))==0),...
        find(cellfun(@isempty,cellfun(@findstr,u_dirs,repmat({'delete'},size(u_dirs)),'UniformOutput',false))==0)];
    u_dirs(subdirs2exclude) = [];
    u_types(subdirs2exclude) = [];
    func_idx = find(cellfun(@strcmp,u_types,repmat({'func'},size(u_types))));
    func_dirs = u_dirs(func_idx);
    
    fileseps = findstr(filesep,subj_info.target_dir);
    subject_name = subj_info.target_dir(fileseps(end)+1:end);
    fprintf('subject name is %s\n',subject_name);
    
    for f = 1:numel(func_dirs) % loop over func datasets
        %% combine echoes
        if strcmp(func_dirs{f},'func')
            funcdir = fullfile(subj_info.target_dir,'func');
            info_dir = fullfile(subj_info.target_dir,'info');
        else
            funcdir = fullfile(subj_info.target_dir,['func_',func_dirs{f}]);
            info_dir = fullfile(subj_info.target_dir,['info_',func_dirs{f}]);
        end
        spike_outputdir = fullfile(info_dir,'spikecheck');
        
        if ~exist(funcdir); mkdir(funcdir); end;
        funcdir = fullfile(subj_info.target_dir,func_dirs{f});
        % get voxel size to determine smoothing kernel
        funcs = dir(funcdir);
        func_info = dicominfo(fullfile(funcdir,funcs(3).name));
        if numel(unique(func_info.PixelSpacing)) > 1; keyboard; end; % check for isotropic voxels in x and y dimensions
        MEsmoothKernelSize = INFO.preproc.multiecho.smoothKernelRatio * func_info.PixelSpacing(1);
        % ME_Combine_commandline(sourcePath,targetPath,numberOfEchoes,WeightVol
        % umes,prescanPath,numberOfRuns,smoothing,KernelSize)
        ME_Combine_commandline(funcdir,funcdir,nEchoes,INFO.preproc.nPrescans,[],[],INFO.preproc.multiecho.smoothing,MEsmoothKernelSize);
        
        % clean up func folder if desired
        if INFO.preproc.cleanup_funcs
            cleanup_in_between_niis(subj_info.target_dir,false,1,false)
        end
        
        % define target folders
        combined_dir = fullfile(funcdir,INFO.dir.multiecho.combined);
        converted_dir = fullfile(funcdir,INFO.dir.multiecho.converted);
        
        % copy mean functionals, RPs and T1
        cd(combined_dir);
        converted_vols = dir('M_volume*.nii');
        converted_vols(1:INFO.preproc.nPrescans) = [];
        rp_file = dir('rp*.txt');
        cd(converted_dir);
        mean_func = dir('mean*.nii');
        if numel(mean_func)~=1 || numel(rp_file)~= 1; keyboard; end
        mean_func_copy = fullfile(combined_dir,['mean_echo1_',subject_name,'.nii']);
        copyfile(mean_func.name,mean_func_copy);
        cd(combined_dir);
        rp = load(rp_file.name);
        rp = rp(INFO.preproc.nPrescans+1:end,:);
        rp_newpath = fullfile(combined_dir,['rp_',subject_name,'_',num2str(INFO.preproc.nPrescans+1),'_onwards.txt']);
        save(rp_newpath,'rp','-ascii');
        
        %% convert T1
        t1_dir = fullfile(subj_info.target_dir,'T1');
        load('t1_conversion_example_job.mat');
        cd(t1_dir);
        imas = dir('*.IMA');
        if numel(imas)~=192; keyboard;end;
        matlabbatch{1}.spm.util.dicom.data = {};
        for i = 1:numel(imas)
            matlabbatch{1}.spm.util.dicom.data{i,1} = fullfile(t1_dir,imas(i).name);
        end
        matlabbatch{1}.spm.util.dicom.outdir{1} = t1_dir;
        save(fullfile(t1_dir,'conversion_job.mat'),'matlabbatch');
        spm_jobman('run',matlabbatch);
        clear matlabbatch
        
        % get T1 path
        t1_convpath = dir('*.nii');
        t1_convpath(find(cellfun(@isempty,cellfun(@findstr,repmat({subject_name},1,numel(t1_convpath)),{t1_convpath.name},'UniformOutput',false))==0)) = [];
        if numel(t1_convpath)~=1;keyboard;end
        if strcmp(func_dirs{f},'func')
            t1_newpath = fullfile(t1_dir,['T1_',subject_name,'.nii']);
        else
            t1_newpath = fullfile(t1_dir,['T1_',subject_name,'_',func_dirs{f},'.nii']);
        end
        movefile(t1_convpath.name,t1_newpath);
        
        %% do preprocessing
        load preproc_example_job_control
        % 1) check the combined images for spikes
        matlabbatch{1}.dmb{1}.check_data_quality{1}.cfg_check_spikes.data = {};
        for i = 1:numel(converted_vols)
            matlabbatch{1}.dmb{1}.check_data_quality{1}.cfg_check_spikes.data{i,1} = [fullfile(combined_dir,converted_vols(i).name),',1'];
        end
        matlabbatch{1}.dmb{1}.check_data_quality{1}.cfg_check_spikes.output_dir = {spike_outputdir};
        % 2) do slice timing (works with dependencies, therefore no input here)
        % 3) coregister mean functional (echo 1) to func template and apply to all functional images
        matlabbatch{3}.spm.spatial.coreg.estimate.source{1} = [mean_func_copy,',1'];
        % 4) coregister T1 to T1 template
        matlabbatch{4}.spm.spatial.coreg.estimate.source{1} = [t1_newpath,',1'];
        % 5) segment the T1
        matlabbatch{5}.spm.spatial.preproc.data{1} = [t1_newpath,',1'];
        % 6) coregister the mean functional to the bias-corrected T1 (produced
        % in step 5)
        matlabbatch{6}.spm.spatial.coreg.estimate.source{1} = [mean_func_copy,',1'];
        % 7) write functionals in normalized space (works with dependencies, therefore no input here)
        % 8) write structural images in normalized space (works with dependencies, therefore no input here)
        % 9) smooth functional images (works with dependencies, therefore no input here)
        
        % save and run preprocessing job
        if ~exist(spike_outputdir); mkdir(spike_outputdir); end
        if ~exist(info_dir); mkdir(info_dir); end
        
        preproc_jobfile = fullfile(info_dir,[subject_name,'_preproc_job.mat']);
        save(preproc_jobfile,'matlabbatch');
        fprintf('saved preprocessing jobfile: %s\n',preproc_jobfile);
        cd(funcdir);
        if INFO.preproc.run_immediately
            fprintf('running jobfile: %s\n',preproc_jobfile);
            spm_jobman('run',matlabbatch);
        else
            fprintf('Chosen not to execute jobs immediately, skipping compartment signal part of the job because it relies on files generated by the batch');
            return
        end
        
        %% get compartment signals & combine with realignment regressors
        if strcmp(func_dirs{f},'func')
            newsegment_dir = fullfile(t1_dir,'new_segment');
        else
            newsegment_dir = fullfile(t1_dir,'new_segment_',func_dirs{f});
        end
        if ~exist(newsegment_dir); mkdir(newsegment_dir); end
        newsegment_t1_path = fullfile(newsegment_dir,['T1_',subject_name,'.nii']);
        copyfile(t1_newpath,newsegment_t1_path);
        clear matlabbatch
        load example_compsig_job_coreg
        matlabbatch{1}.dmb{1}.nuisance_regressors{1}.preproc8.channel.vols = {[newsegment_t1_path,',1']};
        % find functional (slice-time corrected, not yet normalized) files
        cd(combined_dir);
        stc_files = dir('a*.nii');
        for i = 2:4
            matlabbatch{i}.spm.spatial.coreg.write.ref = {[fullfile(combined_dir,stc_files(1).name),',1']};
        end
        
        matlabbatch{5}.dmb{1}.nuisance_regressors{1}.segment_regressors.data = {};
        for i = 1:numel(stc_files)
            matlabbatch{5}.dmb{1}.nuisance_regressors{1}.segment_regressors.data{i,1} = ...
                [fullfile(combined_dir,stc_files(i).name),',1'];
        end
        
        matlabbatch{5}.dmb{1}.nuisance_regressors{1}.segment_regressors.directory{1}{1} = info_dir; % save compsig regressors to info dir
        rmfield(matlabbatch{6}.dmb{1}.nuisance_regressors{1}.deriv_mov_pars,'regressor')
        matlabbatch{6}.dmb{1}.nuisance_regressors{1}.deriv_mov_pars.regressors = {rp_newpath};
        matlabbatch{7}.dmb{1}.nuisance_regressors{1}.combine_regressors.subj_info.target_dir{1} = info_dir;
        matlabbatch{7}.dmb{1}.nuisance_regressors{1}.combine_regressors.filename = [subject_name,'_rp_rp1stderiv_compsig'];
        matlabbatch{8}.dmb{1}.nuisance_regressors{1}.combine_regressors.subj_info.target_dir{1} = info_dir;
        matlabbatch{8}.dmb{1}.nuisance_regressors{1}.combine_regressors.filename = [subject_name,'_rp_rp1stderiv'];
        compsig_jobfile = fullfile(info_dir,[subject_name,'_compsig_job.mat']);
        save(compsig_jobfile,'matlabbatch');
        spm_jobman('run',matlabbatch);
    end % loop over functional sessions
end % loop over subjects

cleanup_in_between_niis(subj_info.target_dir,true,1:5,false);
toc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Other functions
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function initialise_SPM
% initialises SPM and the toolboxes we need

spm fmri; % initialise SPM
addpath(genpath('/home/common/matlab/spm_batch/fraleo/dmb'));
% [p1,p2,p3] = fileparts(mfilename('fullpath'));
% addpath(p1); % add the path from which we run this function again to make sure that custom batch functions are used from this path
cfg_util('addapp', dmb_cfg);

